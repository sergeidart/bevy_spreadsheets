// src/sheets/systems/ai/processor/navigator.rs
//! Index Mapper / Navigator
//!
//! This module is CRITICAL for fixing the index mismatch bug.
//! It manages stable row IDs that persist across processing steps,
//! ensuring human-readable display values are used instead of raw indexes.
//!
//! ## Responsibilities
//!
//! - Track original row indexes (from grid/DB) with their display values
//! - Assign MAX+1 indexes to AI-added rows
//! - Persist index mappings across multi-step processing
//! - Provide display value resolution for any row (original or AI-added)
//!
//! ## Usage Flow
//!
//! 1. Pre-processor calls `register_original_rows()` at step start
//! 2. After AI response, call `register_ai_added_rows()` for new rows
//! 3. Storager uses these stable IDs for result storage
//! 4. Next step reads display values from Navigator (not grid indexes)

use std::collections::HashMap;

/// Origin type for a row - whether it came from the database or was AI-generated
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RowOrigin {
    /// Row exists in the database/grid
    Original,
    /// Row was generated by AI (not in database yet)
    AiAdded,
}

/// Stable identifier for a row that persists across processing steps.
/// This is the key to fixing the index mismatch bug.
#[derive(Debug, Clone)]
pub struct StableRowId {
    /// The table this row belongs to
    pub table_name: String,
    /// Category of the table (if any)
    pub category: Option<String>,
    /// Stable index: original DB row_index OR assigned sequential index for AI-added
    pub stable_index: usize,
    /// Human-readable display value from the key column (e.g., "MiG-25PD")
    /// This is what should be shown in logs and sent to AI, NOT the raw index
    pub display_value: String,
    /// Origin of this row
    pub origin: RowOrigin,
    /// For structure tables: the parent's stable row ID reference
    pub parent_stable_index: Option<usize>,
    /// For structure tables: the parent's table name
    pub parent_table_name: Option<String>,
}

impl StableRowId {
    /// Create a new StableRowId for an original (database) row
    pub fn new_original(
        table_name: String,
        category: Option<String>,
        db_row_index: usize,
        display_value: String,
        parent_stable_index: Option<usize>,
        parent_table_name: Option<String>,
    ) -> Self {
        Self {
            table_name,
            category,
            stable_index: db_row_index,
            display_value,
            origin: RowOrigin::Original,
            parent_stable_index,
            parent_table_name,
        }
    }

    /// Create a new StableRowId for an AI-added row
    pub fn new_ai_added(
        table_name: String,
        category: Option<String>,
        assigned_index: usize,
        display_value: String,
        parent_stable_index: Option<usize>,
        parent_table_name: Option<String>,
    ) -> Self {
        Self {
            table_name,
            category,
            stable_index: assigned_index,
            display_value,
            origin: RowOrigin::AiAdded,
            parent_stable_index,
            parent_table_name,
        }
    }

    /// Check if this is an AI-added row
    pub fn is_ai_added(&self) -> bool {
        self.origin == RowOrigin::AiAdded
    }

    /// Check if this is an original (database) row
    pub fn is_original(&self) -> bool {
        self.origin == RowOrigin::Original
    }

    /// Get the original row index if this is an Original row
    /// Returns None for AI-added rows
    pub fn original_row_index(&self) -> Option<usize> {
        if self.is_original() {
            Some(self.stable_index)
        } else {
            None
        }
    }

    /// Get the AI sequence number if this is an AI-added row
    /// Returns None for original rows
    pub fn ai_sequence(&self) -> Option<usize> {
        if self.is_ai_added() {
            Some(self.stable_index)
        } else {
            None
        }
    }
}

/// Key for looking up rows in the index mapper
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TableRowKey {
    pub table_name: String,
    pub category: Option<String>,
    pub stable_index: usize,
}

impl TableRowKey {
    pub fn new(table_name: String, category: Option<String>, stable_index: usize) -> Self {
        Self {
            table_name,
            category,
            stable_index,
        }
    }

    pub fn from_stable_id(stable_id: &StableRowId) -> Self {
        Self {
            table_name: stable_id.table_name.clone(),
            category: stable_id.category.clone(),
            stable_index: stable_id.stable_index,
        }
    }
}

/// Table-specific tracking for index management
#[derive(Debug, Clone, Default)]
struct TableIndexTracker {
    /// Maximum original index seen for this table
    max_original_index: usize,
    /// Next index to assign for AI-added rows (starts at max_original + 1)
    next_ai_index: usize,
    /// Count of AI-added rows
    ai_added_count: usize,
}

/// Index Mapper - manages stable row IDs across processing steps
///
/// This is the central component for fixing the index mismatch bug.
/// It ensures that:
/// 1. Original rows are tracked with their display values
/// 2. AI-added rows get unique, sequential indexes starting from MAX+1
/// 3. Display values can be resolved for any row at any step
#[derive(Debug, Clone, Default)]
pub struct IndexMapper {
    /// All registered stable row IDs
    /// Key: (table_name, category, stable_index)
    rows: HashMap<TableRowKey, StableRowId>,

    /// Per-table index tracking
    table_trackers: HashMap<(String, Option<String>), TableIndexTracker>,

    /// Display value lookup: (table, category, display_value) -> stable_index
    /// Used for matching AI response rows back to original rows
    display_value_index: HashMap<(String, Option<String>, String), usize>,
}

impl IndexMapper {
    /// Create a new IndexMapper
    pub fn new() -> Self {
        Self::default()
    }

    /// Register original rows from the grid/database.
    ///
    /// Call this at the start of each processing step to register the rows
    /// that will be sent to the AI.
    ///
    /// # Arguments
    /// * `table_name` - Name of the table
    /// * `category` - Category of the table (if any)
    /// * `rows` - Vector of (db_row_index, display_value)
    /// * `parent_stable_index` - For structure tables, the parent row's stable index
    ///
    /// # Returns
    /// Vector of created StableRowIds
    pub fn register_original_rows(
        &mut self,
        table_name: &str,
        category: Option<&str>,
        rows: Vec<(usize, String)>,
        parent_stable_index: Option<usize>,
        parent_table_name: Option<String>,
    ) -> Vec<StableRowId> {
        let table_key = (table_name.to_string(), category.map(|s| s.to_string()));
        let tracker = self.table_trackers.entry(table_key.clone()).or_default();

        let mut result = Vec::with_capacity(rows.len());

        for (db_row_index, display_value) in rows {
            // Update max original index
            if db_row_index > tracker.max_original_index {
                tracker.max_original_index = db_row_index;
                // Ensure next_ai_index is always > max_original
                if tracker.next_ai_index <= db_row_index {
                    tracker.next_ai_index = db_row_index + 1;
                }
            }

            let stable_id = StableRowId::new_original(
                table_name.to_string(),
                category.map(|s| s.to_string()),
                db_row_index,
                display_value.clone(),
                parent_stable_index,
                parent_table_name.clone(),
            );

            let key = TableRowKey::from_stable_id(&stable_id);

            // Add to display value index for reverse lookup
            let display_key = (
                table_name.to_string(),
                category.map(|s| s.to_string()),
                display_value.clone(),
            );
            self.display_value_index.insert(display_key, db_row_index);

            // Store the stable ID
            self.rows.insert(key, stable_id.clone());
            result.push(stable_id);
        }

        result
    }

    /// Register AI-added rows (rows created by the AI, not in database).
    ///
    /// Call this after parsing the AI response to register new rows.
    /// Each AI-added row gets a unique index starting from MAX(original) + 1.
    ///
    /// # Arguments
    /// * `table_name` - Name of the table
    /// * `category` - Category of the table (if any)
    /// * `display_values` - Vector of display_value
    /// * `parent_stable_index` - For structure tables, the parent row's stable index
    ///
    /// # Returns
    /// Vector of created StableRowIds with assigned indexes
    pub fn register_ai_added_rows(
        &mut self,
        table_name: &str,
        category: Option<&str>,
        display_values: Vec<String>,
        parent_stable_index: Option<usize>,
        parent_table_name: Option<String>,
    ) -> Vec<StableRowId> {
        let table_key = (table_name.to_string(), category.map(|s| s.to_string()));
        let tracker = self.table_trackers.entry(table_key).or_default();

        // Initialize next_ai_index if this is the first AI-added row
        if tracker.next_ai_index == 0 && tracker.max_original_index > 0 {
            tracker.next_ai_index = tracker.max_original_index + 1;
        } else if tracker.next_ai_index == 0 {
            // No original rows seen yet, start from 1
            tracker.next_ai_index = 1;
        }

        let mut result = Vec::with_capacity(display_values.len());

        for display_value in display_values {
            let assigned_index = tracker.next_ai_index;
            tracker.next_ai_index += 1;
            tracker.ai_added_count += 1;

            let stable_id = StableRowId::new_ai_added(
                table_name.to_string(),
                category.map(|s| s.to_string()),
                assigned_index,
                display_value.clone(),
                parent_stable_index,
                parent_table_name.clone(),
            );

            let key = TableRowKey::from_stable_id(&stable_id);

            // Add to display value index
            let display_key = (
                table_name.to_string(),
                category.map(|s| s.to_string()),
                display_value,
            );
            self.display_value_index.insert(display_key, assigned_index);

            self.rows.insert(key, stable_id.clone());
            result.push(stable_id);
        }

        result
    }

    /// Get a StableRowId by table and index
    pub fn get(&self, table_name: &str, category: Option<&str>, stable_index: usize) -> Option<&StableRowId> {
        let key = TableRowKey::new(
            table_name.to_string(),
            category.map(|s| s.to_string()),
            stable_index,
        );
        self.rows.get(&key)
    }

    /// Get display value for a row.
    ///
    /// Find a row by its display value.
    ///
    /// Used when parsing AI responses to match rows back to originals.
    /// Returns the stable_index if found.
    pub fn find_by_display_value(
        &self,
        table_name: &str,
        category: Option<&str>,
        display_value: &str,
    ) -> Option<usize> {
        let key = (
            table_name.to_string(),
            category.map(|s| s.to_string()),
            display_value.to_string(),
        );
        self.display_value_index.get(&key).copied()
    }

    /// Clear all data (use when starting a fresh processing session)
    pub fn clear(&mut self) {
        self.rows.clear();
        self.table_trackers.clear();
        self.display_value_index.clear();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_register_original_rows() {
        let mut mapper = IndexMapper::new();

        let rows = vec![
            (0, "MiG-25PD".to_string()),
            (1, "LaGG-3 Series 4".to_string()),
            (2, "F-16C".to_string()),
        ];

        let stable_ids = mapper.register_original_rows("Aircraft", Some("USSR"), rows, None, None);

        assert_eq!(stable_ids.len(), 3);
        assert_eq!(stable_ids[0].display_value, "MiG-25PD");
        assert_eq!(stable_ids[0].stable_index, 0);
        assert!(stable_ids[0].is_original());
    }

    #[test]
    fn test_register_ai_added_rows() {
        let mut mapper = IndexMapper::new();

        // First register some original rows
        let originals = vec![
            (0, "MiG-25PD".to_string()),
            (5, "F-16C".to_string()), // Note: index 5, not sequential
        ];
        mapper.register_original_rows("Aircraft", None, originals, None, None);

        // Now add AI rows - should start from MAX(original) + 1 = 6
        let ai_rows = vec![
            "Su-27".to_string(),
            "New Fighter".to_string(),
        ];
        let ai_stable_ids = mapper.register_ai_added_rows("Aircraft", None, ai_rows, None, None);

        assert_eq!(ai_stable_ids.len(), 2);
        assert_eq!(ai_stable_ids[0].stable_index, 6); // MAX(5) + 1
        assert_eq!(ai_stable_ids[1].stable_index, 7);
        assert!(ai_stable_ids[0].is_ai_added());
    }

    #[test]
    fn test_find_by_display_value() {
        let mut mapper = IndexMapper::new();

        let rows = vec![
            (10, "MiG-25PD".to_string()),
            (20, "LaGG-3 Series 4".to_string()),
        ];
        mapper.register_original_rows("Aircraft", None, rows, None, None);

        // Find by display value
        assert_eq!(mapper.find_by_display_value("Aircraft", None, "MiG-25PD"), Some(10));
        assert_eq!(mapper.find_by_display_value("Aircraft", None, "LaGG-3 Series 4"), Some(20));
        assert_eq!(mapper.find_by_display_value("Aircraft", None, "NonExistent"), None);
    }
}